# Test Jig
Reverse engineering the MusicCast protocol using Wireshark can be a little bit tedious.
The workflow I used is

1. Use Wireshark to capture traffic between the ios MusicCast app and real MusicCast speakers
1. To improve signal-to-noise ratio I use my OpenWRT router and disconnect it from the network leaving only those two devices. Capture is done on the router as this [blog post demonstrates](http://threatvectorsecurity.blogspot.com.au/2014/06/openwrt-tcpdump-packet-captures-for.html)
1. Inspect Wireshark captures to determine what API's need to be emulated
1. Emulate those APIs with some small descrepency (bug)
1. Look to the heavens to wonder why the IOS MusicCast app isn't treating my fake Swimbait server like a real one
1. Inspect responses to confirm they are exactly the same  

To improve the workflow I added [`ActivityLogMiddleware.cs`](https://github.com/neutmute/swimbait/blob/master/src/server/Middleware/ActivityLogMiddleware.cs) to the `Server` project and this *Test*`Jig` project.

### ActivityLogMiddleware.cs
When Yamaha's MusicCast application discovers the Swimbait server it sends a flurry of HTTP requests so it that it can be added to the app's list of speakers.

This middleware class logs the *requests* made from the official MusicCast App to the Swimbait Server. The logs are written to disk in csv format. Lets call this file the `activity log`.

### Jig
This project parses the `activity log` generated by the middleware and replays those same requests to a real MusicCast speaker. At the same time it plays the requests to the Swimbait server.

It writes the responses to two different files in a manner that makes comparison between the Swimbait response and the real Yamaha speaker easy to compare with your favorite file diff.

By using the file diff it makes it easier and faster to see where a particular response from the Swimbait server is noncompliant. 

It also illustrates which requests have not yet been emulated correctly.  

 